{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "2ba1043a-e3be-3043-a8c9-de6419d72041",
              "name": "resources.rules.raptor-signed-unsigned-conversion",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.raptor-signed-unsigned-conversion"
              },
              "fullDescription": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "help": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://cwe.mitre.org/data/definitions/195](https://cwe.mitre.org/data/definitions/195)\n - [https://cwe.mitre.org/data/definitions/196](https://cwe.mitre.org/data/definitions/196)\n - [https://cwe.mitre.org/data/definitions/194](https://cwe.mitre.org/data/definitions/194)\n - [https://cwe.mitre.org/data/definitions/191](https://cwe.mitre.org/data/definitions/191)\n - [https://cwe.mitre.org/data/definitions/681](https://cwe.mitre.org/data/definitions/681)\n - [https://cwe.mitre.org/data/definitions/789](https://cwe.mitre.org/data/definitions/789)\n - [https://g.co/kgs/PCHQjJ](https://g.co/kgs/PCHQjJ)\n - [https://github.com/struct/mms](https://github.com/struct/mms)\n - [https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf](https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf)\n - [http://www.phrack.org/issues/60/10.html#article](http://www.phrack.org/issues/60/10.html#article)\n - [https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples](https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.raptor-signed-unsigned-conversion"
                ]
              }
            },
            {
              "id": "61c45b7e-4c86-30a3-a6c6-6ae11411e0c1",
              "name": "resources.rules.raptor-suspicious-assert",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.raptor-suspicious-assert"
              },
              "fullDescription": {
                "text": "Most codebases define assertion macros which compile to a no-op on non-debug builds. If assertions are the only line of defense against untrusted input, the software may be exposed to attacks that leverage the lack of proper input checks."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "help": {
                "text": "Most codebases define assertion macros which compile to a no-op on non-debug builds. If assertions are the only line of defense against untrusted input, the software may be exposed to attacks that leverage the lack of proper input checks.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "Most codebases define assertion macros which compile to a no-op on non-debug builds. If assertions are the only line of defense against untrusted input, the software may be exposed to attacks that leverage the lack of proper input checks.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://legends2k.github.io/note/assert_vs_if/](https://legends2k.github.io/note/assert_vs_if/)\n - [https://github.com/struct/mms](https://github.com/struct/mms)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.raptor-suspicious-assert"
                ]
              }
            },
            {
              "id": "99e0b4fc-1a99-3cf8-b49e-303591c74d54",
              "name": "resources.rules.raptor-signed-unsigned-conversion",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.raptor-signed-unsigned-conversion"
              },
              "fullDescription": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "help": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://cwe.mitre.org/data/definitions/195](https://cwe.mitre.org/data/definitions/195)\n - [https://cwe.mitre.org/data/definitions/196](https://cwe.mitre.org/data/definitions/196)\n - [https://cwe.mitre.org/data/definitions/194](https://cwe.mitre.org/data/definitions/194)\n - [https://cwe.mitre.org/data/definitions/191](https://cwe.mitre.org/data/definitions/191)\n - [https://cwe.mitre.org/data/definitions/681](https://cwe.mitre.org/data/definitions/681)\n - [https://cwe.mitre.org/data/definitions/789](https://cwe.mitre.org/data/definitions/789)\n - [https://g.co/kgs/PCHQjJ](https://g.co/kgs/PCHQjJ)\n - [https://github.com/struct/mms](https://github.com/struct/mms)\n - [https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf](https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf)\n - [http://www.phrack.org/issues/60/10.html#article](http://www.phrack.org/issues/60/10.html#article)\n - [https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples](https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.raptor-signed-unsigned-conversion"
                ]
              }
            },
            {
              "id": "04f5bc90-c350-3ae0-aa27-234179779fb6",
              "name": "resources.rules.raptor-signed-unsigned-conversion",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.raptor-signed-unsigned-conversion"
              },
              "fullDescription": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "help": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://cwe.mitre.org/data/definitions/195](https://cwe.mitre.org/data/definitions/195)\n - [https://cwe.mitre.org/data/definitions/196](https://cwe.mitre.org/data/definitions/196)\n - [https://cwe.mitre.org/data/definitions/194](https://cwe.mitre.org/data/definitions/194)\n - [https://cwe.mitre.org/data/definitions/191](https://cwe.mitre.org/data/definitions/191)\n - [https://cwe.mitre.org/data/definitions/681](https://cwe.mitre.org/data/definitions/681)\n - [https://cwe.mitre.org/data/definitions/789](https://cwe.mitre.org/data/definitions/789)\n - [https://g.co/kgs/PCHQjJ](https://g.co/kgs/PCHQjJ)\n - [https://github.com/struct/mms](https://github.com/struct/mms)\n - [https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf](https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf)\n - [http://www.phrack.org/issues/60/10.html#article](http://www.phrack.org/issues/60/10.html#article)\n - [https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples](https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.raptor-signed-unsigned-conversion"
                ]
              }
            },
            {
              "id": "1d451d6a-3d08-3a37-81e8-b4a78f2b7020",
              "name": "resources.rules.raptor-signed-unsigned-conversion",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.raptor-signed-unsigned-conversion"
              },
              "fullDescription": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "help": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://cwe.mitre.org/data/definitions/195](https://cwe.mitre.org/data/definitions/195)\n - [https://cwe.mitre.org/data/definitions/196](https://cwe.mitre.org/data/definitions/196)\n - [https://cwe.mitre.org/data/definitions/194](https://cwe.mitre.org/data/definitions/194)\n - [https://cwe.mitre.org/data/definitions/191](https://cwe.mitre.org/data/definitions/191)\n - [https://cwe.mitre.org/data/definitions/681](https://cwe.mitre.org/data/definitions/681)\n - [https://cwe.mitre.org/data/definitions/789](https://cwe.mitre.org/data/definitions/789)\n - [https://g.co/kgs/PCHQjJ](https://g.co/kgs/PCHQjJ)\n - [https://github.com/struct/mms](https://github.com/struct/mms)\n - [https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf](https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf)\n - [http://www.phrack.org/issues/60/10.html#article](http://www.phrack.org/issues/60/10.html#article)\n - [https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples](https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.raptor-signed-unsigned-conversion"
                ]
              }
            },
            {
              "id": "533f2286-ee96-36f8-bd32-68e6c6433f26",
              "name": "resources.rules.raptor-signed-unsigned-conversion",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.raptor-signed-unsigned-conversion"
              },
              "fullDescription": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "help": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://cwe.mitre.org/data/definitions/195](https://cwe.mitre.org/data/definitions/195)\n - [https://cwe.mitre.org/data/definitions/196](https://cwe.mitre.org/data/definitions/196)\n - [https://cwe.mitre.org/data/definitions/194](https://cwe.mitre.org/data/definitions/194)\n - [https://cwe.mitre.org/data/definitions/191](https://cwe.mitre.org/data/definitions/191)\n - [https://cwe.mitre.org/data/definitions/681](https://cwe.mitre.org/data/definitions/681)\n - [https://cwe.mitre.org/data/definitions/789](https://cwe.mitre.org/data/definitions/789)\n - [https://g.co/kgs/PCHQjJ](https://g.co/kgs/PCHQjJ)\n - [https://github.com/struct/mms](https://github.com/struct/mms)\n - [https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf](https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf)\n - [http://www.phrack.org/issues/60/10.html#article](http://www.phrack.org/issues/60/10.html#article)\n - [https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples](https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.raptor-signed-unsigned-conversion"
                ]
              }
            },
            {
              "id": "8ea82d37-e343-3213-a2da-9600c3c75883",
              "name": "resources.rules.raptor-signed-unsigned-conversion",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.raptor-signed-unsigned-conversion"
              },
              "fullDescription": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "help": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://cwe.mitre.org/data/definitions/195](https://cwe.mitre.org/data/definitions/195)\n - [https://cwe.mitre.org/data/definitions/196](https://cwe.mitre.org/data/definitions/196)\n - [https://cwe.mitre.org/data/definitions/194](https://cwe.mitre.org/data/definitions/194)\n - [https://cwe.mitre.org/data/definitions/191](https://cwe.mitre.org/data/definitions/191)\n - [https://cwe.mitre.org/data/definitions/681](https://cwe.mitre.org/data/definitions/681)\n - [https://cwe.mitre.org/data/definitions/789](https://cwe.mitre.org/data/definitions/789)\n - [https://g.co/kgs/PCHQjJ](https://g.co/kgs/PCHQjJ)\n - [https://github.com/struct/mms](https://github.com/struct/mms)\n - [https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf](https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf)\n - [http://www.phrack.org/issues/60/10.html#article](http://www.phrack.org/issues/60/10.html#article)\n - [https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples](https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.raptor-signed-unsigned-conversion"
                ]
              }
            },
            {
              "id": "4a424262-3fe9-32cb-aa60-65134b6753be",
              "name": "resources.rules.raptor-signed-unsigned-conversion",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.raptor-signed-unsigned-conversion"
              },
              "fullDescription": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "help": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://cwe.mitre.org/data/definitions/195](https://cwe.mitre.org/data/definitions/195)\n - [https://cwe.mitre.org/data/definitions/196](https://cwe.mitre.org/data/definitions/196)\n - [https://cwe.mitre.org/data/definitions/194](https://cwe.mitre.org/data/definitions/194)\n - [https://cwe.mitre.org/data/definitions/191](https://cwe.mitre.org/data/definitions/191)\n - [https://cwe.mitre.org/data/definitions/681](https://cwe.mitre.org/data/definitions/681)\n - [https://cwe.mitre.org/data/definitions/789](https://cwe.mitre.org/data/definitions/789)\n - [https://g.co/kgs/PCHQjJ](https://g.co/kgs/PCHQjJ)\n - [https://github.com/struct/mms](https://github.com/struct/mms)\n - [https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf](https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf)\n - [http://www.phrack.org/issues/60/10.html#article](http://www.phrack.org/issues/60/10.html#article)\n - [https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples](https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.raptor-signed-unsigned-conversion"
                ]
              }
            },
            {
              "id": "39cf7b50-229c-3d98-96c5-7f32aa8e5f8d",
              "name": "resources.rules.raptor-signed-unsigned-conversion",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.raptor-signed-unsigned-conversion"
              },
              "fullDescription": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "help": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://cwe.mitre.org/data/definitions/195](https://cwe.mitre.org/data/definitions/195)\n - [https://cwe.mitre.org/data/definitions/196](https://cwe.mitre.org/data/definitions/196)\n - [https://cwe.mitre.org/data/definitions/194](https://cwe.mitre.org/data/definitions/194)\n - [https://cwe.mitre.org/data/definitions/191](https://cwe.mitre.org/data/definitions/191)\n - [https://cwe.mitre.org/data/definitions/681](https://cwe.mitre.org/data/definitions/681)\n - [https://cwe.mitre.org/data/definitions/789](https://cwe.mitre.org/data/definitions/789)\n - [https://g.co/kgs/PCHQjJ](https://g.co/kgs/PCHQjJ)\n - [https://github.com/struct/mms](https://github.com/struct/mms)\n - [https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf](https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf)\n - [http://www.phrack.org/issues/60/10.html#article](http://www.phrack.org/issues/60/10.html#article)\n - [https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples](https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.raptor-signed-unsigned-conversion"
                ]
              }
            },
            {
              "id": "5bcbe2c6-44d4-3f31-8fa6-34ca857dd733",
              "name": "resources.rules.raptor-suspicious-assert",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.raptor-suspicious-assert"
              },
              "fullDescription": {
                "text": "Most codebases define assertion macros which compile to a no-op on non-debug builds. If assertions are the only line of defense against untrusted input, the software may be exposed to attacks that leverage the lack of proper input checks."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "help": {
                "text": "Most codebases define assertion macros which compile to a no-op on non-debug builds. If assertions are the only line of defense against untrusted input, the software may be exposed to attacks that leverage the lack of proper input checks.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "Most codebases define assertion macros which compile to a no-op on non-debug builds. If assertions are the only line of defense against untrusted input, the software may be exposed to attacks that leverage the lack of proper input checks.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://legends2k.github.io/note/assert_vs_if/](https://legends2k.github.io/note/assert_vs_if/)\n - [https://github.com/struct/mms](https://github.com/struct/mms)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.raptor-suspicious-assert"
                ]
              }
            },
            {
              "id": "b345f8d2-abc5-338e-9e0f-8eb95d48f090",
              "name": "resources.rules.raptor-signed-unsigned-conversion",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.raptor-signed-unsigned-conversion"
              },
              "fullDescription": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "help": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://cwe.mitre.org/data/definitions/195](https://cwe.mitre.org/data/definitions/195)\n - [https://cwe.mitre.org/data/definitions/196](https://cwe.mitre.org/data/definitions/196)\n - [https://cwe.mitre.org/data/definitions/194](https://cwe.mitre.org/data/definitions/194)\n - [https://cwe.mitre.org/data/definitions/191](https://cwe.mitre.org/data/definitions/191)\n - [https://cwe.mitre.org/data/definitions/681](https://cwe.mitre.org/data/definitions/681)\n - [https://cwe.mitre.org/data/definitions/789](https://cwe.mitre.org/data/definitions/789)\n - [https://g.co/kgs/PCHQjJ](https://g.co/kgs/PCHQjJ)\n - [https://github.com/struct/mms](https://github.com/struct/mms)\n - [https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf](https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf)\n - [http://www.phrack.org/issues/60/10.html#article](http://www.phrack.org/issues/60/10.html#article)\n - [https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples](https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.raptor-signed-unsigned-conversion"
                ]
              }
            },
            {
              "id": "0d6629d1-8ed8-33a4-ad73-0e9fde2e4a96",
              "name": "resources.rules.raptor-signed-unsigned-conversion",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.raptor-signed-unsigned-conversion"
              },
              "fullDescription": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "help": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://cwe.mitre.org/data/definitions/195](https://cwe.mitre.org/data/definitions/195)\n - [https://cwe.mitre.org/data/definitions/196](https://cwe.mitre.org/data/definitions/196)\n - [https://cwe.mitre.org/data/definitions/194](https://cwe.mitre.org/data/definitions/194)\n - [https://cwe.mitre.org/data/definitions/191](https://cwe.mitre.org/data/definitions/191)\n - [https://cwe.mitre.org/data/definitions/681](https://cwe.mitre.org/data/definitions/681)\n - [https://cwe.mitre.org/data/definitions/789](https://cwe.mitre.org/data/definitions/789)\n - [https://g.co/kgs/PCHQjJ](https://g.co/kgs/PCHQjJ)\n - [https://github.com/struct/mms](https://github.com/struct/mms)\n - [https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf](https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf)\n - [http://www.phrack.org/issues/60/10.html#article](http://www.phrack.org/issues/60/10.html#article)\n - [https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples](https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.raptor-signed-unsigned-conversion"
                ]
              }
            },
            {
              "id": "64067734-a6ba-314b-a427-9b87f698de28",
              "name": "resources.rules.raptor-signed-unsigned-conversion",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.raptor-signed-unsigned-conversion"
              },
              "fullDescription": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "help": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://cwe.mitre.org/data/definitions/195](https://cwe.mitre.org/data/definitions/195)\n - [https://cwe.mitre.org/data/definitions/196](https://cwe.mitre.org/data/definitions/196)\n - [https://cwe.mitre.org/data/definitions/194](https://cwe.mitre.org/data/definitions/194)\n - [https://cwe.mitre.org/data/definitions/191](https://cwe.mitre.org/data/definitions/191)\n - [https://cwe.mitre.org/data/definitions/681](https://cwe.mitre.org/data/definitions/681)\n - [https://cwe.mitre.org/data/definitions/789](https://cwe.mitre.org/data/definitions/789)\n - [https://g.co/kgs/PCHQjJ](https://g.co/kgs/PCHQjJ)\n - [https://github.com/struct/mms](https://github.com/struct/mms)\n - [https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf](https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf)\n - [http://www.phrack.org/issues/60/10.html#article](http://www.phrack.org/issues/60/10.html#article)\n - [https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples](https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.raptor-signed-unsigned-conversion"
                ]
              }
            },
            {
              "id": "45c8c9d1-cb3e-3720-aecc-68e9408f8036",
              "name": "resources.rules.raptor-interesting-api-calls",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.raptor-interesting-api-calls"
              },
              "fullDescription": {
                "text": "Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "help": {
                "text": "Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://github.com/0xdea/ghidra-scripts/blob/main/Rhabdomancer.java](https://github.com/0xdea/ghidra-scripts/blob/main/Rhabdomancer.java)\n - [https://github.com/x509cert/banned/blob/master/banned.h](https://github.com/x509cert/banned/blob/master/banned.h)\n - [https://g.co/kgs/PCHQjJ](https://g.co/kgs/PCHQjJ)\n - [https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf](https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf)\n - [https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/28719-banned-api-usage-use-updated-function-replacement](https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/28719-banned-api-usage-use-updated-function-replacement)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.raptor-interesting-api-calls"
                ]
              }
            },
            {
              "id": "fc161f62-16d5-3344-869f-16926ec485b3",
              "name": "resources.rules.raptor-signed-unsigned-conversion",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.raptor-signed-unsigned-conversion"
              },
              "fullDescription": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "help": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://cwe.mitre.org/data/definitions/195](https://cwe.mitre.org/data/definitions/195)\n - [https://cwe.mitre.org/data/definitions/196](https://cwe.mitre.org/data/definitions/196)\n - [https://cwe.mitre.org/data/definitions/194](https://cwe.mitre.org/data/definitions/194)\n - [https://cwe.mitre.org/data/definitions/191](https://cwe.mitre.org/data/definitions/191)\n - [https://cwe.mitre.org/data/definitions/681](https://cwe.mitre.org/data/definitions/681)\n - [https://cwe.mitre.org/data/definitions/789](https://cwe.mitre.org/data/definitions/789)\n - [https://g.co/kgs/PCHQjJ](https://g.co/kgs/PCHQjJ)\n - [https://github.com/struct/mms](https://github.com/struct/mms)\n - [https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf](https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf)\n - [http://www.phrack.org/issues/60/10.html#article](http://www.phrack.org/issues/60/10.html#article)\n - [https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples](https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.raptor-signed-unsigned-conversion"
                ]
              }
            },
            {
              "id": "690dbc64-b2b1-3c66-95d9-0bbe60711984",
              "name": "resources.rules.string-is-comparison",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.string-is-comparison"
              },
              "fullDescription": {
                "text": "Found string comparison using 'is' operator. The 'is' operator\nis for reference equality, not value equality, and therefore should\nnot be used to compare strings. For more information, see\nhttps://github.com/satwikkansal/wtfpython#-how-not-to-use-is-operator\"\n"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "help": {
                "text": "Found string comparison using 'is' operator. The 'is' operator\nis for reference equality, not value equality, and therefore should\nnot be used to compare strings. For more information, see\nhttps://github.com/satwikkansal/wtfpython#-how-not-to-use-is-operator\"\n\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "Found string comparison using 'is' operator. The 'is' operator\nis for reference equality, not value equality, and therefore should\nnot be used to compare strings. For more information, see\nhttps://github.com/satwikkansal/wtfpython#-how-not-to-use-is-operator\"\n\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.string-is-comparison"
                ]
              }
            },
            {
              "id": "6015bc84-c54c-3678-8b69-f39f80ae9b24",
              "name": "resources.rules.raptor-signed-unsigned-conversion",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.raptor-signed-unsigned-conversion"
              },
              "fullDescription": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "help": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://cwe.mitre.org/data/definitions/195](https://cwe.mitre.org/data/definitions/195)\n - [https://cwe.mitre.org/data/definitions/196](https://cwe.mitre.org/data/definitions/196)\n - [https://cwe.mitre.org/data/definitions/194](https://cwe.mitre.org/data/definitions/194)\n - [https://cwe.mitre.org/data/definitions/191](https://cwe.mitre.org/data/definitions/191)\n - [https://cwe.mitre.org/data/definitions/681](https://cwe.mitre.org/data/definitions/681)\n - [https://cwe.mitre.org/data/definitions/789](https://cwe.mitre.org/data/definitions/789)\n - [https://g.co/kgs/PCHQjJ](https://g.co/kgs/PCHQjJ)\n - [https://github.com/struct/mms](https://github.com/struct/mms)\n - [https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf](https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf)\n - [http://www.phrack.org/issues/60/10.html#article](http://www.phrack.org/issues/60/10.html#article)\n - [https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples](https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.raptor-signed-unsigned-conversion"
                ]
              }
            },
            {
              "id": "3769e668-d108-3dd8-810d-b89dc8521b09",
              "name": "resources.rules.raptor-signed-unsigned-conversion",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.raptor-signed-unsigned-conversion"
              },
              "fullDescription": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "help": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://cwe.mitre.org/data/definitions/195](https://cwe.mitre.org/data/definitions/195)\n - [https://cwe.mitre.org/data/definitions/196](https://cwe.mitre.org/data/definitions/196)\n - [https://cwe.mitre.org/data/definitions/194](https://cwe.mitre.org/data/definitions/194)\n - [https://cwe.mitre.org/data/definitions/191](https://cwe.mitre.org/data/definitions/191)\n - [https://cwe.mitre.org/data/definitions/681](https://cwe.mitre.org/data/definitions/681)\n - [https://cwe.mitre.org/data/definitions/789](https://cwe.mitre.org/data/definitions/789)\n - [https://g.co/kgs/PCHQjJ](https://g.co/kgs/PCHQjJ)\n - [https://github.com/struct/mms](https://github.com/struct/mms)\n - [https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf](https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf)\n - [http://www.phrack.org/issues/60/10.html#article](http://www.phrack.org/issues/60/10.html#article)\n - [https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples](https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.raptor-signed-unsigned-conversion"
                ]
              }
            },
            {
              "id": "d13e898e-ff0b-30ce-a973-d2d6aaffce1d",
              "name": "resources.rules.raptor-signed-unsigned-conversion",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.raptor-signed-unsigned-conversion"
              },
              "fullDescription": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "help": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://cwe.mitre.org/data/definitions/195](https://cwe.mitre.org/data/definitions/195)\n - [https://cwe.mitre.org/data/definitions/196](https://cwe.mitre.org/data/definitions/196)\n - [https://cwe.mitre.org/data/definitions/194](https://cwe.mitre.org/data/definitions/194)\n - [https://cwe.mitre.org/data/definitions/191](https://cwe.mitre.org/data/definitions/191)\n - [https://cwe.mitre.org/data/definitions/681](https://cwe.mitre.org/data/definitions/681)\n - [https://cwe.mitre.org/data/definitions/789](https://cwe.mitre.org/data/definitions/789)\n - [https://g.co/kgs/PCHQjJ](https://g.co/kgs/PCHQjJ)\n - [https://github.com/struct/mms](https://github.com/struct/mms)\n - [https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf](https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf)\n - [http://www.phrack.org/issues/60/10.html#article](http://www.phrack.org/issues/60/10.html#article)\n - [https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples](https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.raptor-signed-unsigned-conversion"
                ]
              }
            },
            {
              "id": "da44d526-fe14-3395-aa9b-2cabd064f430",
              "name": "resources.rules.raptor-signed-unsigned-conversion",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.raptor-signed-unsigned-conversion"
              },
              "fullDescription": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "help": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://cwe.mitre.org/data/definitions/195](https://cwe.mitre.org/data/definitions/195)\n - [https://cwe.mitre.org/data/definitions/196](https://cwe.mitre.org/data/definitions/196)\n - [https://cwe.mitre.org/data/definitions/194](https://cwe.mitre.org/data/definitions/194)\n - [https://cwe.mitre.org/data/definitions/191](https://cwe.mitre.org/data/definitions/191)\n - [https://cwe.mitre.org/data/definitions/681](https://cwe.mitre.org/data/definitions/681)\n - [https://cwe.mitre.org/data/definitions/789](https://cwe.mitre.org/data/definitions/789)\n - [https://g.co/kgs/PCHQjJ](https://g.co/kgs/PCHQjJ)\n - [https://github.com/struct/mms](https://github.com/struct/mms)\n - [https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf](https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf)\n - [http://www.phrack.org/issues/60/10.html#article](http://www.phrack.org/issues/60/10.html#article)\n - [https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples](https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.raptor-signed-unsigned-conversion"
                ]
              }
            },
            {
              "id": "3bf03d76-ee8c-3cd7-8b09-84a20afd0c5e",
              "name": "resources.rules.raptor-signed-unsigned-conversion",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.raptor-signed-unsigned-conversion"
              },
              "fullDescription": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "help": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://cwe.mitre.org/data/definitions/195](https://cwe.mitre.org/data/definitions/195)\n - [https://cwe.mitre.org/data/definitions/196](https://cwe.mitre.org/data/definitions/196)\n - [https://cwe.mitre.org/data/definitions/194](https://cwe.mitre.org/data/definitions/194)\n - [https://cwe.mitre.org/data/definitions/191](https://cwe.mitre.org/data/definitions/191)\n - [https://cwe.mitre.org/data/definitions/681](https://cwe.mitre.org/data/definitions/681)\n - [https://cwe.mitre.org/data/definitions/789](https://cwe.mitre.org/data/definitions/789)\n - [https://g.co/kgs/PCHQjJ](https://g.co/kgs/PCHQjJ)\n - [https://github.com/struct/mms](https://github.com/struct/mms)\n - [https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf](https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf)\n - [http://www.phrack.org/issues/60/10.html#article](http://www.phrack.org/issues/60/10.html#article)\n - [https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples](https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.raptor-signed-unsigned-conversion"
                ]
              }
            },
            {
              "id": "e545cce7-a9fe-3706-b558-7f4de95680f3",
              "name": "resources.rules.raptor-suspicious-assert",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.raptor-suspicious-assert"
              },
              "fullDescription": {
                "text": "Most codebases define assertion macros which compile to a no-op on non-debug builds. If assertions are the only line of defense against untrusted input, the software may be exposed to attacks that leverage the lack of proper input checks."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "help": {
                "text": "Most codebases define assertion macros which compile to a no-op on non-debug builds. If assertions are the only line of defense against untrusted input, the software may be exposed to attacks that leverage the lack of proper input checks.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "Most codebases define assertion macros which compile to a no-op on non-debug builds. If assertions are the only line of defense against untrusted input, the software may be exposed to attacks that leverage the lack of proper input checks.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://legends2k.github.io/note/assert_vs_if/](https://legends2k.github.io/note/assert_vs_if/)\n - [https://github.com/struct/mms](https://github.com/struct/mms)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.raptor-suspicious-assert"
                ]
              }
            },
            {
              "id": "626d2063-e582-360a-8ffd-e65058b59841",
              "name": "bash.curl.security.curl-pipe-bash.curl-pipe-bash",
              "shortDescription": {
                "text": "Opengrep Finding: bash.curl.security.curl-pipe-bash.curl-pipe-bash"
              },
              "fullDescription": {
                "text": "Data is being piped into `bash` from a `curl` command. An attacker with control of the server in the `curl` command could inject malicious code into the pipe, resulting in a system compromise. Avoid piping untrusted data into `bash` or any other shell if you can. If you must do this, consider checking the SHA sum of the content returned by the server to verify its integrity."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "helpUri": "https://semgrep.dev/r/bash.curl.security.curl-pipe-bash.curl-pipe-bash",
              "help": {
                "text": "Data is being piped into `bash` from a `curl` command. An attacker with control of the server in the `curl` command could inject malicious code into the pipe, resulting in a system compromise. Avoid piping untrusted data into `bash` or any other shell if you can. If you must do this, consider checking the SHA sum of the content returned by the server to verify its integrity.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "Data is being piped into `bash` from a `curl` command. An attacker with control of the server in the `curl` command could inject malicious code into the pipe, resulting in a system compromise. Avoid piping untrusted data into `bash` or any other shell if you can. If you must do this, consider checking the SHA sum of the content returned by the server to verify its integrity.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/bash.curl.security.curl-pipe-bash.curl-pipe-bash)\n - [https://owasp.org/Top10/A03_2021-Injection](https://owasp.org/Top10/A03_2021-Injection)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "bash.curl.security.curl-pipe-bash.curl-pipe-bash"
                ]
              }
            },
            {
              "id": "666caa1e-f519-3fc0-9712-4f214ed8fd8c",
              "name": "resources.rules.raptor-signed-unsigned-conversion",
              "shortDescription": {
                "text": "Opengrep Finding: resources.rules.raptor-signed-unsigned-conversion"
              },
              "fullDescription": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "warning"
              },
              "help": {
                "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\nðŸ’Ž Enable cross-file analysis and Pro rules for free at sg.run/pro",
                "markdown": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic.\n\n#### ðŸ’Ž Enable cross-file analysis and Pro rules for free at <a href='https://sg.run/pro'>sg.run/pro</a>\n\n<b>References:</b>\n - [https://cwe.mitre.org/data/definitions/195](https://cwe.mitre.org/data/definitions/195)\n - [https://cwe.mitre.org/data/definitions/196](https://cwe.mitre.org/data/definitions/196)\n - [https://cwe.mitre.org/data/definitions/194](https://cwe.mitre.org/data/definitions/194)\n - [https://cwe.mitre.org/data/definitions/191](https://cwe.mitre.org/data/definitions/191)\n - [https://cwe.mitre.org/data/definitions/681](https://cwe.mitre.org/data/definitions/681)\n - [https://cwe.mitre.org/data/definitions/789](https://cwe.mitre.org/data/definitions/789)\n - [https://g.co/kgs/PCHQjJ](https://g.co/kgs/PCHQjJ)\n - [https://github.com/struct/mms](https://github.com/struct/mms)\n - [https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf](https://www.sei.cmu.edu/downloads/sei-cert-c-coding-standard-2016-v01.pdf)\n - [http://www.phrack.org/issues/60/10.html#article](http://www.phrack.org/issues/60/10.html#article)\n - [https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples](https://docs.microsoft.com/en-us/cpp/sanitizers/asan-error-examples)\n"
              },
              "properties": {
                "precision": "very-high",
                "tags": [
                  "resources.rules.raptor-signed-unsigned-conversion"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "2ba1043a-e3be-3043-a8c9-de6419d72041",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "GPUTreeShap/gpu_treeshap.h",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 443,
                  "startColumn": 10,
                  "endLine": 443,
                  "endColumn": 46,
                  "snippet": {
                    "text": "  size_t path_end = bin_segments[bin_idx + 1];"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "9fd3917a04001d37ae25a4b73b3f81500281e779d71e79f2f47e85aa7827a1ed781ed53094ea9d2b897f3d43fdd35eb66f06cdb6fb1f72e6bbf333a77b51fa57_0"
          },
          "properties": {}
        },
        {
          "ruleId": "61c45b7e-4c86-30a3-a6c6-6ae11411e0c1",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Most codebases define assertion macros which compile to a no-op on non-debug builds. If assertions are the only line of defense against untrusted input, the software may be exposed to attacks that leverage the lack of proper input checks."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "GPUTreeShap/gpu_treeshap.h",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 63,
                  "startColumn": 5,
                  "endLine": 63,
                  "endColumn": 55,
                  "snippet": {
                    "text": "    assert(feature_lower_bound <= feature_upper_bound);"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "bf612b66ae0d0ed0e4c6c3fccc35e184389fe70d7f2f02c5dc5eb29ddb2ef18b84eeb35c0486e885502c2aae19aabc339718fbd87c9487c910422c45db068d94_0"
          },
          "properties": {}
        },
        {
          "ruleId": "99e0b4fc-1a99-3cf8-b49e-303591c74d54",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "GPUTreeShap/gpu_treeshap.h",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 211,
                  "startColumn": 10,
                  "endLine": 211,
                  "endColumn": 60,
                  "snippet": {
                    "text": "  size_t matrix_size = (num_columns + 1) * (num_columns + 1);"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "4e2267394b42e353cbbdf9fae3aa926a8cb3215e245304631ca4a7b52c28b689540c18b016b7486c041df79fb8dd81214174586109e98d4749be74d4655b8c7f_0"
          },
          "properties": {}
        },
        {
          "ruleId": "04f5bc90-c350-3ae0-aa27-234179779fb6",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "GPUTreeShap/gpu_treeshap.h",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 515,
                  "startColumn": 10,
                  "endLine": 515,
                  "endColumn": 48,
                  "snippet": {
                    "text": "  size_t bins_per_row = bin_segments.size() - 1;"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "41d1c80fd7be023784e5e20db3585407b69a0491bb95f28fc1038f174c070c084bb7b856e4e6fd778635601dc808bac5d422580306b52b387deb5869c4173d70_0"
          },
          "properties": {}
        },
        {
          "ruleId": "1d451d6a-3d08-3a37-81e8-b4a78f2b7020",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "GPUTreeShap/gpu_treeshap.h",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 531,
                  "startColumn": 10,
                  "endLine": 531,
                  "endColumn": 77,
                  "snippet": {
                    "text": "  size_t warps_needed = bins_per_row * DivRoundUp(X.NumRows(), kRowsPerWarp);"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "6f64b3852c9f634d6ee90824724534b60a9066e0f8324184c2a2d5e4e9972e7c586147a604fff51cee40fda110bf242eaed234be3e1a81c8a753d74f58d499d8_0"
          },
          "properties": {}
        },
        {
          "ruleId": "533f2286-ee96-36f8-bd32-68e6c6433f26",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "GPUTreeShap/gpu_treeshap.h",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 654,
                  "startColumn": 10,
                  "endLine": 654,
                  "endColumn": 48,
                  "snippet": {
                    "text": "  size_t bins_per_row = bin_segments.size() - 1;"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "41d1c80fd7be023784e5e20db3585407b69a0491bb95f28fc1038f174c070c084bb7b856e4e6fd778635601dc808bac5d422580306b52b387deb5869c4173d70_1"
          },
          "properties": {}
        },
        {
          "ruleId": "8ea82d37-e343-3213-a2da-9600c3c75883",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "GPUTreeShap/gpu_treeshap.h",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 767,
                  "startColumn": 10,
                  "endLine": 767,
                  "endColumn": 77,
                  "snippet": {
                    "text": "  size_t warps_needed = bins_per_row * DivRoundUp(X.NumRows(), kRowsPerWarp);"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "6f64b3852c9f634d6ee90824724534b60a9066e0f8324184c2a2d5e4e9972e7c586147a604fff51cee40fda110bf242eaed234be3e1a81c8a753d74f58d499d8_2"
          },
          "properties": {}
        },
        {
          "ruleId": "4a424262-3fe9-32cb-aa60-65134b6753be",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "GPUTreeShap/gpu_treeshap.h",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 670,
                  "startColumn": 10,
                  "endLine": 670,
                  "endColumn": 77,
                  "snippet": {
                    "text": "  size_t warps_needed = bins_per_row * DivRoundUp(X.NumRows(), kRowsPerWarp);"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "6f64b3852c9f634d6ee90824724534b60a9066e0f8324184c2a2d5e4e9972e7c586147a604fff51cee40fda110bf242eaed234be3e1a81c8a753d74f58d499d8_1"
          },
          "properties": {}
        },
        {
          "ruleId": "39cf7b50-229c-3d98-96c5-7f32aa8e5f8d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "GPUTreeShap/gpu_treeshap.h",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 751,
                  "startColumn": 10,
                  "endLine": 751,
                  "endColumn": 48,
                  "snippet": {
                    "text": "  size_t bins_per_row = bin_segments.size() - 1;"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "41d1c80fd7be023784e5e20db3585407b69a0491bb95f28fc1038f174c070c084bb7b856e4e6fd778635601dc808bac5d422580306b52b387deb5869c4173d70_2"
          },
          "properties": {}
        },
        {
          "ruleId": "5bcbe2c6-44d4-3f31-8fa6-34ca857dd733",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Most codebases define assertion macros which compile to a no-op on non-debug builds. If assertions are the only line of defense against untrusted input, the software may be exposed to attacks that leverage the lack of proper input checks."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "GPUTreeShap/gpu_treeshap.h",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 788,
                  "startColumn": 3,
                  "endLine": 788,
                  "endColumn": 25,
                  "snippet": {
                    "text": "  assert(n - s - 1 >= 0);"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "2a7183fc7cb29dd1c4913a9f85aa2d9cc9d61abe2fb6e5d41913881670bf2f44faef62f85de3d948134c58cbaa2720c99bbf0fed5067777f40527630cc4f9215_0"
          },
          "properties": {}
        },
        {
          "ruleId": "b345f8d2-abc5-338e-9e0f-8eb95d48f090",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "GPUTreeShap/gpu_treeshap.h",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 883,
                  "startColumn": 10,
                  "endLine": 883,
                  "endColumn": 48,
                  "snippet": {
                    "text": "  size_t bins_per_row = bin_segments.size() - 1;"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "41d1c80fd7be023784e5e20db3585407b69a0491bb95f28fc1038f174c070c084bb7b856e4e6fd778635601dc808bac5d422580306b52b387deb5869c4173d70_3"
          },
          "properties": {}
        },
        {
          "ruleId": "0d6629d1-8ed8-33a4-ad73-0e9fde2e4a96",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "GPUTreeShap/gpu_treeshap.h",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 913,
                  "startColumn": 10,
                  "endLine": 915,
                  "endColumn": 63,
                  "snippet": {
                    "text": "  size_t num_bins =\n      thrust::reduce(thrust::hip::par(alloc), bin_map.begin(), bin_map.end(),\n                     size_t(0), thrust::maximum<size_t>()) + 1;"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "4816c894ced83ca46ef0535beb0cc3e0d0a9db9a9f3642042e9159fce69e83bfd9234d9fe4759c24dca72c1f5f04cf5322a9ab194e43a36708126fc080f2fc57_0"
          },
          "properties": {}
        },
        {
          "ruleId": "64067734-a6ba-314b-a427-9b87f698de28",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "GPUTreeShap/gpu_treeshap.h",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 1146,
                  "startColumn": 10,
                  "endLine": 1146,
                  "endColumn": 25,
                  "snippet": {
                    "text": "  size_t current_bin = 0;"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "b365ec6e611dacb286aeb6bebe978f89c076146f914540ff752263ebb048b86db6cba78b9c4c4e7af93639a5b4e095b19fb0194b9f94770b044570967722f378_0"
          },
          "properties": {}
        },
        {
          "ruleId": "45c8c9d1-cb3e-3720-aecc-68e9408f8036",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Locate all calls to interesting and potentially insecure API functions (candidate points). The auditor can backtrace from these candidate points to find pathways allowing access from untrusted input."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "GPUTreeShap/gpu_treeshap.h",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 976,
                  "startColumn": 13,
                  "endLine": 976,
                  "endColumn": 68,
                  "snippet": {
                    "text": "  CheckCuda(hipHostMalloc(&h_num_runs_out, sizeof(*h_num_runs_out)));"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "a6ddeac75964df7f512d0929167f50dee3aa8f29547399d850e7005bf68d9292e2ad74a4b944e8c81c4273746c734c65170f7a673337b19ec001e72578baa851_0"
          },
          "properties": {}
        },
        {
          "ruleId": "fc161f62-16d5-3344-869f-16926ec485b3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "GPUTreeShap/gpu_treeshap.h",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 899,
                  "startColumn": 10,
                  "endLine": 899,
                  "endColumn": 77,
                  "snippet": {
                    "text": "  size_t warps_needed = bins_per_row * DivRoundUp(X.NumRows(), kRowsPerWarp);"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "6f64b3852c9f634d6ee90824724534b60a9066e0f8324184c2a2d5e4e9972e7c586147a604fff51cee40fda110bf242eaed234be3e1a81c8a753d74f58d499d8_3"
          },
          "properties": {}
        },
        {
          "ruleId": "690dbc64-b2b1-3c66-95d9-0bbe60711984",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Found string comparison using 'is' operator. The 'is' operator\nis for reference equality, not value equality, and therefore should\nnot be used to compare strings. For more information, see\nhttps://github.com/satwikkansal/wtfpython#-how-not-to-use-is-operator\"\n"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "benchmark/benchmark.py",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 148,
                  "startColumn": 16,
                  "endLine": 148,
                  "endColumn": 36,
                  "snippet": {
                    "text": "            if p is \"gpu_predictor\":"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "d573ebedec2b00449a333d5712d9d654aa42fedd4289c28b6c6f42034bab63b05e4c639535eb4bc4c4330cbaa79ccbfa70da625d2a201aabc191221e017943e8_0"
          },
          "properties": {}
        },
        {
          "ruleId": "6015bc84-c54c-3678-8b69-f39f80ae9b24",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "GPUTreeShap/gpu_treeshap.h",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 999,
                  "startColumn": 10,
                  "endLine": 999,
                  "endColumn": 23,
                  "snippet": {
                    "text": "  size_t temp_size = 0;"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "501ee24700ecf721e30fb00eb038b7fb842996a6c83a8af63cb1bfd63c50c844f1c0ac80772680b1614e812cf07b48a8306cc880a44e1329ecf08f409bef92d2_0"
          },
          "properties": {}
        },
        {
          "ruleId": "3769e668-d108-3dd8-810d-b89dc8521b09",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "benchmark/benchmark_gpu_treeshap.cxx",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 33,
                  "startColumn": 12,
                  "endLine": 33,
                  "endColumn": 38,
                  "snippet": {
                    "text": "    size_t num_paths = state.range(3);"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "883fb8a94b9f63a99a18efeb8eb577e7e322e250fc0f02101ce2e45c2b0c7c69256749b7e9009648183d4bd0df30500486b0648359013389280a18d585caeb82_0"
          },
          "properties": {}
        },
        {
          "ruleId": "d13e898e-ff0b-30ce-a973-d2d6aaffce1d",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "benchmark/benchmark_gpu_treeshap.cxx",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 32,
                  "startColumn": 12,
                  "endLine": 32,
                  "endColumn": 38,
                  "snippet": {
                    "text": "    size_t max_depth = state.range(2);"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "b071ac21ee4ec31786363a4411e4a0dc8c34c796a88e08ed810416b13ba585aca4f71935620b86c78b4ff26b58e6066669f2a608c5060c5ed8ee818f43c71765_0"
          },
          "properties": {}
        },
        {
          "ruleId": "da44d526-fe14-3395-aa9b-2cabd064f430",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "benchmark/benchmark_gpu_treeshap.cxx",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 134,
                  "startColumn": 10,
                  "endLine": 134,
                  "endColumn": 28,
                  "snippet": {
                    "text": "  size_t n = state.range(0);"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "d6ed3685e778c8951655ed5490945b151e2dacbf316adf7945ef5f8d70b40fe9e4565ed88acff85794611c025a714aa2bb73cb63d53f51da58fb763e8e620afe_0"
          },
          "properties": {}
        },
        {
          "ruleId": "3bf03d76-ee8c-3cd7-8b09-84a20afd0c5e",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "benchmark/benchmark_gpu_treeshap.cxx",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 135,
                  "startColumn": 10,
                  "endLine": 135,
                  "endColumn": 36,
                  "snippet": {
                    "text": "  size_t max_depth = state.range(1);"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "1f6b80c1e61e2cbf605d0793b5c8a00bf50aed69bdf5b6bd30f0e3ab30a74627dd04b0c693803a5227083e7d7ce6b7db48341525484f15a35ba0709f03612b05_0"
          },
          "properties": {}
        },
        {
          "ruleId": "e545cce7-a9fe-3706-b558-7f4de95680f3",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Most codebases define assertion macros which compile to a no-op on non-debug builds. If assertions are the only line of defense against untrusted input, the software may be exposed to attacks that leverage the lack of proper input checks."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "example/example.cxx",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 95,
                  "startColumn": 5,
                  "endLine": 95,
                  "endColumn": 55,
                  "snippet": {
                    "text": "    assert(feature_lower_bound <= feature_upper_bound);"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "6b14e4fcb5218e964bb968b70d6de9743de305b283014bb234c3dbfa017af37a122647732efb8f5283f92b543b5c1f193afcb4d6388bf56a50b884998a688c5d_0"
          },
          "properties": {}
        },
        {
          "ruleId": "626d2063-e582-360a-8ffd-e65058b59841",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Data is being piped into `bash` from a `curl` command. An attacker with control of the server in the `curl` command could inject malicious code into the pipe, resulting in a system compromise. Avoid piping untrusted data into `bash` or any other shell if you can. If you must do this, consider checking the SHA sum of the content returned by the server to verify its integrity."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "ci/gpu/build.sh",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 1,
                  "endLine": 20,
                  "endColumn": 86,
                  "snippet": {
                    "text": "curl -s https://raw.githubusercontent.com/rapidsai/gpuci-tools/main/install.sh | bash"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "1c302b33252a41bf632ad0602e7043da07daf1f35d87b7188445665cbdafbac876e8bd718b52c98e0c993ea62446b0fd93181d7655ecf44b202c0fdebd5fb3a4_0"
          },
          "properties": {}
        },
        {
          "ruleId": "666caa1e-f519-3fc0-9712-4f214ed8fd8c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "The software uses a signed primitive and performs a cast to an unsigned primitive, or uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value. When the result of a function is to be used as a size parameter, using negative return values can have unexpected results. Although less frequent an issue, unsigned-to-signed conversion can be  the precursor to buffer underwrite conditions. Buffer underwrites  occur frequently when large unsigned values are cast to signed values,  and then used as indexes into a buffer or for pointer arithmetic."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "example/example.cxx",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "startLine": 118,
                  "startColumn": 10,
                  "endLine": 118,
                  "endColumn": 22,
                  "snippet": {
                    "text": "  size_t path_idx = 0;"
                  }
                }
              }
            }
          ],
          "fingerprints": {
            "matchBasedId/v1": "11747ae03e33ccf0f82cb2fd214b454f84da5574a0599d02006af1f2d7710e3d15c27f8e35b21f76a09618b36a4ad2c42ba2099dcc8feaaa55b1c6df8763c69a_0"
          },
          "properties": {}
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}